import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import warnings
import numpy as np
import os
from pathlib import Path
import requests

warnings.filterwarnings('ignore')

class MomentumStrategy:
    def __init__(self, tickers_dict, initial_capital=100000, momentum_threshold_min=1.2, momentum_threshold_max=3.0,
                 max_positions=4, risk_on_leverage=2.0, sma_filter_months=6,
                 macro_filter_ticker='^GSPC', macro_filter_sma_months=10, bok_api_key=None,
                 telegram_token=None, chat_id=None):

        self.tickers_dict = tickers_dict
        self.initial_capital = initial_capital
        self.momentum_threshold_min = momentum_threshold_min
        self.momentum_threshold_max = momentum_threshold_max
        self.max_positions = max_positions
        
        self.risk_on_leverage = risk_on_leverage
        self.current_leverage = self.risk_on_leverage

        self.sma_filter_months = sma_filter_months
        self.macro_filter_ticker = macro_filter_ticker
        self.macro_filter_sma_months = macro_filter_sma_months
        
        self.bok_api_key = bok_api_key
        self.telegram_token = telegram_token
        self.chat_id = chat_id
        self.price_data = None
        self.monthly_returns = []
        self.portfolio_history = []
        self.trade_history = []
        self.selected_assets_history = []
        self.bok_rates_cache = self._get_default_bok_rates()
        self.default_bok_rates = self._get_default_bok_rates()
        self.is_risk_on = True

        filter_info = f"{self.sma_filter_months}Í∞úÏõî SMA ÌïÑÌÑ∞" if self.sma_filter_months > 0 else "Í∞úÎ≥Ñ ÌïÑÌÑ∞ ÏóÜÏùå"
        macro_filter_info = f"{self.macro_filter_sma_months}Í∞úÏõî SMA*1.01 Îß§ÌÅ¨Î°ú ÌïÑÌÑ∞ ({self.macro_filter_ticker})" if self.macro_filter_ticker else "Îß§ÌÅ¨Î°ú ÌïÑÌÑ∞ ÏóÜÏùå"
        print(f"--- Ï†ÑÎûµ Ï¥àÍ∏∞Ìôî: Max Positions={self.max_positions}, Max Leverage={self.risk_on_leverage}x, {filter_info}, {macro_filter_info} ---")

    def send_telegram_message(self, message):
        """ÌÖîÎ†àÍ∑∏Îû®ÏúºÎ°ú Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        if not self.telegram_token or not self.chat_id:
            print("ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ïÏù¥ ÏóÜÏñ¥ ÏΩòÏÜîÏóêÎßå Ï∂úÎ†•Ìï©ÎãàÎã§.")
            return
        
        try:
            url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
            payload = {
                'chat_id': self.chat_id,
                'text': message,
                'parse_mode': 'HTML'
            }
            response = requests.post(url, data=payload)
            if response.status_code == 200:
                print("‚úì ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏôÑÎ£å")
            else:
                print(f"‚ùå ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ° Ïã§Ìå®: {response.status_code}")
        except Exception as e:
            print(f"‚ùå ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ° Ïò§Î•ò: {e}")

    def _prepare_data(self, start_date_str, end_date_str):
        print("\nFetching all historical data in one batch... this may take a moment.")
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d')
        required_offset = max(14, self.sma_filter_months + 2, self.macro_filter_sma_months + 2)
        data_start_date = start_date - pd.DateOffset(months=required_offset)
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d')

        all_tickers = list(self.tickers_dict.values())
        if self.macro_filter_ticker and self.macro_filter_ticker not in all_tickers:
            all_tickers.append(self.macro_filter_ticker)

        try:
            full_data = yf.download(all_tickers, start=data_start_date, end=end_date + timedelta(days=1), progress=True)
            if full_data.empty or not isinstance(full_data.columns, pd.MultiIndex):
                print("üî• Critical error: Failed to download valid data or data has an unexpected format.")
                self.price_data = None
                return

            if 'Adj Close' in full_data.columns.get_level_values(0):
                self.price_data = full_data['Adj Close']
                print("--> Using 'Adj Close' for price data.")
            else:
                self.price_data = full_data['Close']
                print("--> Warning: 'Adj Close' not found. Falling back to 'Close' prices.")

            self.price_data.ffill(inplace=True)
            print("‚úì Historical data has been successfully downloaded and prepared.")
        except Exception as e:
            print(f"üî• Critical error during data download or processing: {e}")
            self.price_data = None

    def _get_default_bok_rates(self):
        return {
            "2018-07": 1.50, "2018-08": 1.50, "2018-09": 1.50, "2018-10": 1.50, "2018-11": 1.75, "2018-12": 1.75,
            "2019-01": 1.75, "2019-02": 1.75, "2019-03": 1.75, "2019-04": 1.75, "2019-05": 1.75, "2019-06": 1.75,
            "2019-07": 1.50, "2019-08": 1.50, "2019-09": 1.50, "2019-10": 1.25, "2019-11": 1.25, "2019-12": 1.25,
            "2020-01": 1.25, "2020-02": 1.25, "2020-03": 0.75, "2020-04": 0.75, "2020-05": 0.50, "2020-06": 0.50,
            "2020-07": 0.50, "2020-08": 0.50, "2020-09": 0.50, "2020-10": 0.50, "2020-11": 0.50, "2020-12": 0.50,
            "2021-01": 0.50, "2021-02": 0.50, "2021-03": 0.50, "2021-04": 0.50, "2021-05": 0.50, "2021-06": 0.50,
            "2021-07": 0.50, "2021-08": 0.75, "2021-09": 0.75, "2021-10": 0.75, "2021-11": 1.00, "2021-12": 1.00,
            "2022-01": 1.25, "2022-02": 1.25, "2022-03": 1.25, "2022-04": 1.50, "2022-05": 1.75, "2022-06": 1.75,
            "2022-07": 2.25, "2022-08": 2.50, "2022-09": 2.50, "2022-10": 3.00, "2022-11": 3.25, "2022-12": 3.25,
            "2023-01": 3.50, "2023-02": 3.50, "2023-03": 3.50, "2023-04": 3.50, "2023-05": 3.50, "2023-06": 3.50,
            "2023-07": 3.50, "2023-08": 3.50, "2023-09": 3.50, "2023-10": 3.50, "2023-11": 3.50, "2023-12": 3.50,
            "2024-01": 3.50, "2024-02": 3.50, "2024-03": 3.50, "2024-04": 3.50, "2024-05": 3.50, "2024-06": 3.50,
            "2024-07": 3.50, "2024-08": 3.50, "2024-09": 3.50, "2024-10": 3.25, "2024-11": 3.00, "2024-12": 3.00,
            "2025-01": 3.00, "2025-02": 2.75, "2025-03": 2.75, "2025-04": 2.75, "2025-05": 2.50, "2025-06": 2.50,
            "2025-07": 2.50
        }

    def get_bok_rate(self, date_str):
        date_obj = datetime.strptime(date_str, '%Y-%m-%d')
        date_key = date_obj.strftime('%Y-%m')
        available_dates = sorted([k for k in self.bok_rates_cache.keys() if k <= date_key])
        return self.bok_rates_cache[available_dates[-1]] if available_dates else 1.50

    def initialize_bok_data(self, start_date, end_date):
        print(f"Í∏∞Ï§ÄÍ∏àÎ¶¨ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî Ï§ë...")
        self.bok_rates_cache = self.default_bok_rates.copy()

    def get_month_end_dates(self, start_date_str, end_date_str):
        all_months = self.price_data.loc[start_date_str:end_date_str].index.to_period('M').unique()
        month_end_dates = [self.price_data.loc[self.price_data.index.to_period('M') == m].index.max() for m in all_months]
        return [d.strftime('%Y-%m-%d') for d in sorted(month_end_dates)]

    def get_trading_day_price(self, ticker, target_date_str):
        try:
            target_date = pd.to_datetime(target_date_str)
            price = self.price_data[ticker].asof(target_date)
            return float(price) if pd.notna(price) else None
        except (KeyError, IndexError):
            return None

    def calculate_momentum_score(self, ticker, end_date_str):
        try:
            end_date = pd.to_datetime(end_date_str)
            ticker_prices = self.price_data[ticker].dropna()

            if ticker_prices.empty: return None

            current_price = ticker_prices.asof(end_date)
            if pd.isna(current_price): return None

            price_ratios = []
            for months_back in range(6, 12):
                target_date = end_date - pd.DateOffset(months=months_back)
                past_prices_in_month = ticker_prices.loc[target_date.to_period('M').start_time : target_date.to_period('M').end_time]
                if past_prices_in_month.empty: continue

                past_price = past_prices_in_month.iloc[-1]
                if pd.notna(past_price) and past_price > 0:
                    price_ratios.append(current_price / past_price)
            
            if len(price_ratios) < 4: return None
            
            return { 'score': sum(price_ratios) / len(price_ratios), 'current_price': current_price }
        except Exception:
            return None

    def analyze_monthly_momentum(self, date_str):
        momentum_results = []
        print(f"\n=== {date_str} Î™®Î©òÌÖÄ Î∂ÑÏÑù ===")
        target_date = pd.to_datetime(date_str)

        if self.macro_filter_ticker:
            macro_window = self.macro_filter_sma_months * 21
            macro_sma_series = self.price_data[self.macro_filter_ticker].rolling(window=macro_window).mean()
            
            current_macro_price = self.get_trading_day_price(self.macro_filter_ticker, date_str)
            macro_sma_value = macro_sma_series.asof(target_date)

            if current_macro_price is not None and pd.notna(macro_sma_value):
                macro_threshold = macro_sma_value * 1.01
                self.is_risk_on = current_macro_price > macro_threshold
                status = "ON" if self.is_risk_on else "OFF"
                print(f"  [Îß§ÌÅ¨Î°ú ÌïÑÌÑ∞] ÏãúÏû• 'ÏúÑÌóò {status}' ÏÉÅÌÉú ({self.macro_filter_ticker} ÌòÑÏû¨Í∞Ä {current_macro_price:.2f} vs {self.macro_filter_sma_months}Í∞úÏõî SMA*1.01 {macro_threshold:.2f})")
            else:
                self.is_risk_on = False
                print("  [Îß§ÌÅ¨Î°ú ÌïÑÌÑ∞] Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±ÏúºÎ°ú 'ÏúÑÌóò OFF' Ï≤òÎ¶¨")
        
        if self.is_risk_on:
            self.current_leverage = self.risk_on_leverage
        else:
            self.current_leverage = 1.0
            print("  - Îß§ÌÅ¨Î°ú ÌïÑÌÑ∞ 'ÏúÑÌóò OFF' ÏÉÅÌÉú. Ï†ÑÎüâ ÌòÑÍ∏à Î≥¥Ïú†Î°ú Ï†ÑÌôòÌï©ÎãàÎã§.")
            print(f"\nÏÑ†ÌÉùÎêú ÏûêÏÇ∞ (0Í∞ú):")
            print(f"\nÏÑ†ÌÉùÎêú ÏûêÏÇ∞Ïù¥ ÏóÜÏùå ‚Üí ÌòÑÍ∏àÏÑ± ÏûêÏÇ∞ Ìà¨Ïûê (Í∏∞Ï§ÄÍ∏àÎ¶¨: {self.get_bok_rate(date_str)}%)")
            return []

        sma_df = None
        if self.sma_filter_months > 0:
            window_size = self.sma_filter_months * 21
            sma_df = self.price_data.rolling(window=window_size).mean()

        for name, ticker in self.tickers_dict.items():
            if self.sma_filter_months > 0 and sma_df is not None:
                current_price = self.get_trading_day_price(ticker, date_str)
                sma_value = sma_df[ticker].asof(target_date)

                if current_price is None or pd.isna(sma_value): continue
                if current_price <= sma_value:
                    print(f"  - {name}: {self.sma_filter_months}Í∞úÏõî SMA ÏïÑÎûò. [ÌïÑÌÑ∞ÎßÅÎê®] (ÌòÑÏû¨Í∞Ä {current_price:.2f} <= SMA {sma_value:.2f})")
                    continue
            
            result = self.calculate_momentum_score(ticker, date_str)
            if result is not None:
                filter_status = f"({self.sma_filter_months}Í∞úÏõî SMA ÌÜµÍ≥º)" if self.sma_filter_months > 0 else ""
                print(f"  - {name}: Î™®Î©òÌÖÄ Ï†êÏàò: {result['score']:.3f} {filter_status}")
                momentum_results.append({
                    'name': name, 'ticker': ticker,
                    'momentum_score': result['score'], 'price': result['current_price']
                })

        momentum_results.sort(key=lambda x: x['momentum_score'], reverse=True)

        qualified_assets = []
        for asset in momentum_results:
            if asset['name'] in ["BTC/KRW", "ETH/KRW"]:
                if self.momentum_threshold_min <= asset['momentum_score'] < 6.0:
                    qualified_assets.append(asset)
            elif asset['name'] == "ÎØ∏Íµ≠ 20ÎÖÑ Íµ≠Ï±Ñ ETF":
                if 1.1 <= asset['momentum_score'] < self.momentum_threshold_max:
                    qualified_assets.append(asset)
            else:
                if self.momentum_threshold_min <= asset['momentum_score'] < self.momentum_threshold_max:
                    qualified_assets.append(asset)
            if len(qualified_assets) >= self.max_positions:
                break
        
        final_assets = self._apply_crypto_weight_limit(qualified_assets)
        print(f"\nÏÑ†ÌÉùÎêú ÏûêÏÇ∞ ({len(final_assets)}Í∞ú):")
        for i, asset in enumerate(final_assets, 1):
            weight_info = f" (Weight: {asset.get('target_weight', 1/len(final_assets))*100:.1f}%)"
            print(f"{i}. {asset['name']}: {asset['momentum_score']:.3f}{weight_info}")
        if not final_assets:
            print(f"\nÏÑ†ÌÉùÎêú ÏûêÏÇ∞Ïù¥ ÏóÜÏùå ‚Üí ÌòÑÍ∏àÏÑ± ÏûêÏÇ∞ Ìà¨Ïûê (Í∏∞Ï§ÄÍ∏àÎ¶¨: {self.get_bok_rate(date_str)}%)")
        return final_assets

    def _apply_crypto_weight_limit(self, qualified_assets):
        crypto_assets = [a for a in qualified_assets if a['name'] in ["BTC/KRW", "ETH/KRW"]]
        non_crypto_assets = [a for a in qualified_assets if a['name'] not in ["BTC/KRW", "ETH/KRW"]]

        if not crypto_assets: return qualified_assets
        if not non_crypto_assets:
            selected_cryptos = crypto_assets[:2]
            weight = 0.5 / len(selected_cryptos) if selected_cryptos else 0
            for c in selected_cryptos: c['target_weight'] = weight
            return selected_cryptos
        else:
            max_crypto_count = min(2, len(crypto_assets))
            selected_cryptos = crypto_assets[:max_crypto_count]
            remaining_slots = self.max_positions - len(selected_cryptos)
            selected_non_cryptos = non_crypto_assets[:remaining_slots]
            total_assets = selected_cryptos + selected_non_cryptos
            crypto_ratio = len(selected_cryptos) / len(total_assets)

            if crypto_ratio > 0.5:
                crypto_weight = 0.5 / len(selected_cryptos)
                non_crypto_weight = 0.5 / len(selected_non_cryptos) if selected_non_cryptos else 0
            else:
                equal_weight = 1.0 / len(total_assets)
                crypto_weight, non_crypto_weight = equal_weight, equal_weight

            for asset in total_assets:
                asset['target_weight'] = crypto_weight if asset in selected_cryptos else non_crypto_weight
            return total_assets

    def calculate_monthly_return(self, selected_assets, buy_date, sell_date):
        if not selected_assets:
            bok_rate = self.get_bok_rate(sell_date)
            cash_return = (bok_rate / 100) / 12
            print(f"ÌòÑÍ∏à Ìà¨Ïûê - Ïõî ÏàòÏùµÎ•†: {cash_return * 100:.4f}%")
            return cash_return

        total_weighted_return, total_weight = 0.0, 0.0
        for asset in selected_assets:
            ticker, weight = asset['ticker'], asset.get('target_weight', 1.0 / len(selected_assets))
            buy_price, sell_price = self.get_trading_day_price(ticker, buy_date), self.get_trading_day_price(ticker, sell_date)

            if buy_price and sell_price and buy_price > 0:
                asset_return = (sell_price - buy_price) / buy_price
                leveraged_return = asset_return * self.current_leverage
                total_weighted_return += leveraged_return * weight
                total_weight += weight
                print(f"  {asset['name']}: {buy_price:.2f} ‚Üí {sell_price:.2f} ({asset_return * 100:+.2f}%) | {self.current_leverage}x Î†àÎ≤ÑÎ¶¨ÏßÄ Ï†ÅÏö©: {leveraged_return * 100:+.2f}% (ÎπÑÏ§ë: {weight*100:.1f}%)")
            else:
                print(f"  {asset['name']}: Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏñ¥ Í≥ÑÏÇ∞ÏóêÏÑú Ï†úÏô∏Îê©ÎãàÎã§.")

        cash_weight = 1.0 - total_weight
        if cash_weight > 1e-6:
            bok_rate = self.get_bok_rate(sell_date)
            cash_return = (bok_rate / 100) / 12
            total_weighted_return += cash_return * cash_weight
            print(f"  ÌòÑÍ∏à: (Ïõî ÏàòÏùµÎ•† {cash_return*100:.4f}%) x {cash_weight*100:.1f}%")

        return total_weighted_return

    def analyze_current_portfolio(self):
        print(f"\n{'=' * 80}\nÌòÑÏû¨ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î∂ÑÏÑù (Today's Portfolio)\n{'=' * 80}")
        today, analysis_date = datetime.now(), datetime.now().strftime('%Y-%m-%d')
        self._prepare_data("2015-01-01", analysis_date)
        if self.price_data is None:
            error_msg = "Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌï¥ ÌòÑÏû¨ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î∂ÑÏÑùÏùÑ Ï¢ÖÎ£åÌï©ÎãàÎã§."
            print(error_msg)
            self.send_telegram_message(f"‚ùå <b>Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î∂ÑÏÑù Ïã§Ìå®</b>\n\n{error_msg}")
            return

        last_trading_day = self.price_data.index.max().strftime('%Y-%m-%d')
        print(f"Î∂ÑÏÑù Í∏∞Ï§ÄÏùº: {last_trading_day}")
        selected_assets = self.analyze_monthly_momentum(last_trading_day)

        leverage_info = f"{self.current_leverage}x Î†àÎ≤ÑÎ¶¨ÏßÄ" if self.is_risk_on else "ÌòÑÍ∏à Î≥¥Ïú† (ÏúÑÌóò OFF)"
        
        telegram_msg = f"üìä <b>Î™®Î©òÌÖÄ Ï†ÑÎûµ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§</b>\n"
        telegram_msg += f"üìÖ <b>Î∂ÑÏÑùÏùº:</b> {last_trading_day}\n"
        telegram_msg += f"‚ö° <b>ÏÉÅÌÉú:</b> {leverage_info}\n\n"
        
        if selected_assets:
            total_risk_weight = sum(a.get('target_weight', 1/len(selected_assets)) for a in selected_assets)
            telegram_msg += f"‚úÖ <b>Ìà¨Ïûê ÎåÄÏÉÅ ÏûêÏÇ∞ ({len(selected_assets)}Í∞ú):</b>\n\n"
            for i, asset in enumerate(selected_assets, 1):
                weight = asset.get('target_weight', 1/len(selected_assets))
                telegram_msg += f"{i}. <b>{asset['name']}</b>\n"
                telegram_msg += f"   ‚Ä¢ ÎπÑÏ§ë: {weight * 100:.1f}%\n"
                telegram_msg += f"   ‚Ä¢ Î™®Î©òÌÖÄ Ï†êÏàò: {asset['momentum_score']:.3f}\n\n"
            
            cash_weight = 1.0 - total_risk_weight
            if cash_weight > 1e-6:
                telegram_msg += f"üíµ <b>ÌòÑÍ∏àÏÑ± ÏûêÏÇ∞:</b> {cash_weight * 100:.1f}%\n\n"
        else:
            bok_rate = self.get_bok_rate(last_trading_day)
            telegram_msg += f"‚ùå <b>Ìà¨Ïûê Ï°∞Í±¥ ÎßåÏ°± ÏûêÏÇ∞ ÏóÜÏùå</b>\n"
            telegram_msg += f"üíµ Ï†ÑÏï° ÌòÑÍ∏àÏÑ± ÏûêÏÇ∞ Ìà¨Ïûê\n"
            telegram_msg += f"üìà Í∏∞Ï§ÄÍ∏àÎ¶¨: {bok_rate}%\n\n"
        
        if self.macro_filter_ticker:
            macro_status = "ON ‚úÖ" if self.is_risk_on else "OFF ‚ùå"
            telegram_msg += f"üåç <b>Îß§ÌÅ¨Î°ú ÌïÑÌÑ∞:</b> ÏúÑÌóò {macro_status}\n"
            telegram_msg += f"üìä Í∏∞Ï§Ä: {self.macro_filter_ticker} > 10Í∞úÏõî SMA*1.01"
        
        print(f"\n{'=' * 60}\nüìä ÌòÑÏû¨ Ìà¨Ïûê Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏöîÏïΩ ({leverage_info})\n{'=' * 60}")
        if selected_assets:
            total_risk_weight = sum(a.get('target_weight', 1/len(selected_assets)) for a in selected_assets)
            print(f"\n‚úÖ Ìà¨Ïûê ÎåÄÏÉÅ ÏûêÏÇ∞ ({len(selected_assets)}Í∞ú):\n")
            for i, asset in enumerate(selected_assets, 1):
                weight = asset.get('target_weight', 1/len(selected_assets))
                print(f"  {i}. {asset['name']} (ÎπÑÏ§ë: {weight * 100:.1f}%, Ï†êÏàò: {asset['momentum_score']:.3f})")
            cash_weight = 1.0 - total_risk_weight
            if cash_weight > 1e-6:
                print(f"  üíµ ÌòÑÍ∏àÏÑ± ÏûêÏÇ∞ (ÎπÑÏ§ë: {cash_weight * 100:.1f}%)")
        else:
            print("\n‚ùå ÌòÑÏû¨ Ìà¨Ïûê Ï°∞Í±¥ÏùÑ ÎßåÏ°±ÌïòÎäî ÏûêÏÇ∞Ïù¥ ÏóÜÏäµÎãàÎã§. Ï†ÑÏï° ÌòÑÍ∏àÏÑ± ÏûêÏÇ∞ Ìà¨Ïûê.")
        print(f"\n{'=' * 60}")
        
        self.send_telegram_message(telegram_msg)
        return selected_assets


if __name__ == "__main__":
    tickers = {
        "S&P 500": "^GSPC", "ÎÇòÏä§Îã• Ï¢ÖÌï©": "^IXIC", "ÎãàÏºÄÏù¥ 225": "^N225",
        "Ïù∏ÎèÑ Sensex": "^BSESN", "Î∏åÎùºÏßà Bovespa": "^BVSP", "FTSE 100": "^FTSE",
        "Ïù∏ÎèÑÎÑ§ÏãúÏïÑ JSX": "^JKSE", "ÎèÖÏùº DAX": "^GDAXI", "ÏÉÅÌï¥ Ï¢ÖÌï©": "000001.SS",
        "KOSPI 200": "^KS200", "ÌôçÏΩ© HÏßÄÏàò": "^HSCE", "BTC/KRW": "BTC-KRW",
        "ETH/KRW": "ETH-KRW", "Í∏à ÏÑ†Î¨º": "GC=F", "ÎØ∏Íµ≠ 20ÎÖÑ Íµ≠Ï±Ñ ETF": "TLT"
    }
    
    strategy = MomentumStrategy(
        tickers_dict=tickers,
        initial_capital=330000000,
        momentum_threshold_min=1.2,
        momentum_threshold_max=3.0,
        max_positions=4,
        risk_on_leverage=2.0,
        sma_filter_months=6,
        macro_filter_ticker='^GSPC',
        macro_filter_sma_months=10,
        bok_api_key="YOUR_API_KEY",
        telegram_token="7200427583:AAE6ZBTRvhfSnrYWstUsOGdgnN4YUxy7OcQ",  # ÌÖîÎ†àÍ∑∏Îû® Î¥á ÌÜ†ÌÅ∞
        chat_id="6932457088"         # ÌÖîÎ†àÍ∑∏Îû® Ï±ÑÌåÖ ID
    )

    # ÌòÑÏû¨ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î∂ÑÏÑùÎßå Ïã§Ìñâ
    strategy.analyze_current_portfolio()
