import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta, timezone
import warnings
import numpy as np
import requests
import os
import logging
from typing import Dict, List, Optional, Tuple
import sys
import platform

# ê²½ê³  ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
warnings.filterwarnings('ignore')

# ======================== [í™˜ê²½ ë””ë²„ê¹…] ========================
def debug_environment():
    """í™˜ê²½ ì •ë³´ ì¶œë ¥"""
    print(f"Python ë²„ì „: {sys.version}")
    print(f"í”Œë«í¼: {platform.platform()}")
    print(f"pandas ë²„ì „: {pd.__version__}")
    print(f"yfinance ë²„ì „: {yf.__version__}")
    print(f"í˜„ì¬ ì‹œê°„ (UTC): {datetime.utcnow()}")
    print(f"í˜„ì¬ ì‹œê°„ (ë¡œì»¬): {datetime.now()}")
    print(f"ì‘ì—… ë””ë ‰í† ë¦¬: {os.getcwd()}")
    
    # ë„¤íŠ¸ì›Œí¬ í…ŒìŠ¤íŠ¸
    try:
        response = requests.get("https://finance.yahoo.com", timeout=10)
        print(f"Yahoo Finance ì ‘ê·¼: âœ“ (ìƒíƒœì½”ë“œ: {response.status_code})")
    except Exception as e:
        print(f"Yahoo Finance ì ‘ê·¼: âŒ ({e})")

# ======================== [ë¡œê¹… ì„¤ì •] ========================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('main.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ======================== [ì„¤ì •] ========================
# í™˜ê²½ë³€ìˆ˜ì—ì„œ í† í° ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ë³´ì•ˆ ê°•í™”)
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN', '7200427583:AAE6ZBTRvhfSnrYWstUsOGdgnN4YUxy7OcQ')
CHAT_ID = os.getenv('CHAT_ID', '6932457088')

# ë¶„ì„ ëŒ€ìƒ ìì‚° (PythonAnywhereì—ì„œ ì˜ ì‘ë™í•˜ëŠ” ì‹¬í”Œí•œ í‹°ì»¤ë“¤)
tickers = {
    "S&P 500": "^GSPC",
    "ë‚˜ìŠ¤ë‹¥": "^IXIC", 
    "ë¹„íŠ¸ì½”ì¸": "BTC-USD",
    "ê¸ˆ": "GC=F",
    "ë¯¸êµ­ êµ­ì±„": "TLT"
}

# ëª¨ë©˜í…€ ë¶„ì„ ì„¤ì •
MOMENTUM_MIN_SCORE = 1.0  # ë” ê´€ëŒ€í•œ ìµœì†Œ ì ìˆ˜
MOMENTUM_MAX_SCORE = 4.0  # ë” ê´€ëŒ€í•œ ìµœëŒ€ ì ìˆ˜
MAX_ASSETS = 3  # ìµœëŒ€ ì„ íƒ ìì‚° ìˆ˜
ANALYSIS_PERIOD_YEARS = 1  # ë¶„ì„ ê¸°ê°„ì„ 1ë…„ìœ¼ë¡œ ë‹¨ì¶•

# ======================== [í•¨ìˆ˜] ========================
def send_telegram(message: str) -> bool:
    """í…”ë ˆê·¸ë¨ìœ¼ë¡œ ë©”ì‹œì§€ ì „ì†¡"""
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    data = {
        "chat_id": CHAT_ID,
        "text": message,
        "parse_mode": "HTML"
    }

    try:
        response = requests.post(url, data=data, timeout=10)
        if response.status_code == 200:
            logger.info("âœ“ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì„±ê³µ")
            return True
        else:
            logger.error(f"âš ï¸ í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨: {response.text}")
            return False
    except Exception as e:
        logger.error(f"âš ï¸ í…”ë ˆê·¸ë¨ ì „ì†¡ ì˜¤ë¥˜: {e}")
        return False

def safe_normalize_index(df):
    """ì•ˆì „í•œ ì¸ë±ìŠ¤ ì •ê·œí™”"""
    try:
        # timezone ì •ë³´ ì œê±°
        if hasattr(df.index, 'tz') and df.index.tz is not None:
            df.index = df.index.tz_convert(None)
        
        # DatetimeIndex ë³€í™˜
        if not isinstance(df.index, pd.DatetimeIndex):
            df.index = pd.to_datetime(df.index)
        
        # normalize ì ìš©
        if hasattr(df.index, 'normalize'):
            df.index = df.index.normalize()
        else:
            # normalizeê°€ ì—†ë‹¤ë©´ ì‹œê°„ ë¶€ë¶„ì„ ìˆ˜ë™ìœ¼ë¡œ ì œê±°
            df.index = df.index.date
            df.index = pd.to_datetime(df.index)
            
        return df
    except Exception as e:
        logger.warning(f"ì¸ë±ìŠ¤ ì •ê·œí™” ì‹¤íŒ¨: {e}")
        return df

def download_single_ticker(ticker: str, start_date: datetime, end_date: datetime, retries: int = 3):
    """ë‹¨ì¼ í‹°ì»¤ ë‹¤ìš´ë¡œë“œ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)"""
    for attempt in range(retries):
        try:
            logger.info(f"ë‹¤ìš´ë¡œë“œ ì‹œë„ {attempt+1}/{retries}: {ticker}")
            
            # ê°„ë‹¨í•œ ë‹¤ìš´ë¡œë“œ ì‹œë„
            data = yf.download(
                ticker, 
                start=start_date.date(), 
                end=(end_date + timedelta(days=1)).date(),
                progress=False,
                show_errors=False,
                timeout=30
            )
            
            if data.empty:
                logger.warning(f"ë¹ˆ ë°ì´í„°: {ticker}")
                continue
                
            # Adj Close ë˜ëŠ” Close ì„ íƒ
            if 'Adj Close' in data.columns and not data['Adj Close'].isna().all():
                price_series = data['Adj Close'].dropna()
            elif 'Close' in data.columns and not data['Close'].isna().all():
                price_series = data['Close'].dropna()
            else:
                logger.warning(f"ê°€ê²© ë°ì´í„° ì—†ìŒ: {ticker}")
                continue
            
            if len(price_series) < 50:  # ìµœì†Œ 50ì¼ ë°ì´í„° í•„ìš”
                logger.warning(f"ë°ì´í„° ë¶€ì¡±: {ticker} ({len(price_series)}ì¼)")
                continue
                
            # ì¸ë±ìŠ¤ ì •ê·œí™”
            price_series = safe_normalize_index(pd.DataFrame({'price': price_series}))['price']
            
            logger.info(f"âœ“ ë‹¤ìš´ë¡œë“œ ì„±ê³µ: {ticker} ({len(price_series)}ì¼)")
            return price_series
            
        except Exception as e:
            logger.warning(f"ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ {attempt+1}: {ticker} - {e}")
            if attempt < retries - 1:
                import time
                time.sleep(2)  # 2ì´ˆ ëŒ€ê¸° í›„ ì¬ì‹œë„
            continue
    
    logger.error(f"ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨: {ticker}")
    return None

def download_data_robust(tickers_dict: Dict[str, str], start_date: datetime, end_date: datetime) -> pd.DataFrame:
    """ê°•í™”ëœ ë°ì´í„° ë‹¤ìš´ë¡œë“œ"""
    logger.info(f"ê°•í™”ëœ ë°ì´í„° ë‹¤ìš´ë¡œë“œ: {start_date.date()} ~ {end_date.date()}")
    
    all_data = {}
    
    for name, ticker in tickers_dict.items():
        price_data = download_single_ticker(ticker, start_date, end_date)
        if price_data is not None:
            all_data[ticker] = price_data
    
    if not all_data:
        raise ValueError("ë‹¤ìš´ë¡œë“œëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    
    # DataFrame ê²°í•©
    data = pd.DataFrame(all_data)
    data = data.ffill().dropna()
    
    logger.info(f"âœ“ ìµœì¢… ë°ì´í„°: {len(data)}ì¼, {len(data.columns)}ê°œ ìì‚°")
    return data

def calculate_momentum(prices: pd.Series, target_date: datetime) -> Tuple[Optional[float], Optional[float]]:
    """ëª¨ë©˜í…€ ì ìˆ˜ ê³„ì‚° (ê°„ì†Œí™”)"""
    try:
        # target_dateë¥¼ pandas Timestampë¡œ ë³€í™˜
        target_ts = pd.Timestamp(target_date.date())
        
        # í˜„ì¬ ê°€ê²© (target_date ì´ì „ì˜ ìµœì‹  ê°€ê²©)
        current_prices = prices.loc[prices.index.normalize() <= target_ts]
        if current_prices.empty:
            return None, None
        current_price = current_prices.iloc[-1]
        
        # 3ê°œì›”, 6ê°œì›” ì „ ê°€ê²© (ê¸°ê°„ ë‹¨ì¶•)
        three_months_ago = target_ts - pd.DateOffset(months=3)
        six_months_ago = target_ts - pd.DateOffset(months=6)
        
        price_3m_series = prices.loc[prices.index.normalize() <= three_months_ago]
        price_6m_series = prices.loc[prices.index.normalize() <= six_months_ago]
        
        if price_3m_series.empty or price_6m_series.empty:
            return None, None
            
        price_3m = price_3m_series.iloc[-1]
        price_6m = price_6m_series.iloc[-1]
        
        # ëª¨ë©˜í…€ ì ìˆ˜ ê³„ì‚°
        momentum_3m = current_price / price_3m
        momentum_6m = current_price / price_6m
        score = (momentum_3m + momentum_6m) / 2
        
        return round(score, 3), current_price
        
    except Exception as e:
        logger.warning(f"ëª¨ë©˜í…€ ê³„ì‚° ì‹¤íŒ¨: {e}")
        return None, None

def analyze_individual_asset(name: str, ticker: str, data: pd.DataFrame, target_date: datetime) -> Optional[Dict]:
    """ê°œë³„ ìì‚° ë¶„ì„"""
    if ticker not in data.columns:
        return None
    
    try:
        score, price = calculate_momentum(data[ticker], target_date)
        if score is None:
            return None
        
        # ë³€ë™ì„± ê³„ì‚° (ê°„ì†Œí™”)
        returns = data[ticker].pct_change().dropna()
        volatility = returns.std() * np.sqrt(252) if len(returns) > 0 else None
        
        return {
            'name': name,
            'ticker': ticker,
            'score': score,
            'price': price,
            'volatility': round(volatility, 3) if volatility is not None else None
        }
    except Exception as e:
        logger.error(f"ìì‚° ë¶„ì„ ì‹¤íŒ¨ {name}: {e}")
        return None

def select_assets(results: List[Dict]) -> List[Dict]:
    """ëª¨ë©˜í…€ ê¸°ì¤€ìœ¼ë¡œ ìì‚° ì„ íƒ"""
    filtered = [r for r in results if r['score'] is not None and MOMENTUM_MIN_SCORE <= r['score'] < MOMENTUM_MAX_SCORE]
    sorted_assets = sorted(filtered, key=lambda x: x['score'], reverse=True)
    return sorted_assets[:MAX_ASSETS]

def create_portfolio_message(selected_assets: List[Dict], date: datetime) -> str:
    """í¬íŠ¸í´ë¦¬ì˜¤ ë©”ì‹œì§€ ìƒì„±"""
    date_str = date.strftime('%Y-%m-%d')
    message = f"ğŸ“Š <b>{date_str} ëª¨ë©˜í…€ í¬íŠ¸í´ë¦¬ì˜¤</b>\n\n"
    
    if not selected_assets:
        message += "âŒ ì¡°ê±´ì— ë§ëŠ” ìì‚° ì—†ìŒ â†’ í˜„ê¸ˆ ë³´ìœ  ê¶Œì¥\n"
        message += f"(ì ìˆ˜ ë²”ìœ„: {MOMENTUM_MIN_SCORE}~{MOMENTUM_MAX_SCORE})"
        return message
    
    weight = round(100 / len(selected_assets), 1)
    
    for i, asset in enumerate(selected_assets, 1):
        message += f"<b>{i}. {asset['name']}</b>\n"
        message += f"   â€¢ ëª¨ë©˜í…€ ì ìˆ˜: {asset['score']}\n"
        message += f"   â€¢ ë¹„ì¤‘: {weight}%\n"
        message += f"   â€¢ í˜„ì¬ê°€: ${asset['price']:,.2f}\n\n"
    
    return message

def analyze_momentum():
    """ë©”ì¸ ë¶„ì„ í•¨ìˆ˜"""
    logger.info("ğŸš€ ëª¨ë©˜í…€ ë¶„ì„ ì‹œì‘")
    
    # í™˜ê²½ ë””ë²„ê¹…
    debug_environment()
    
    try:
        end_date = datetime.now()
        start_date = end_date - timedelta(days=365)
        
        # ê°•í™”ëœ ë°ì´í„° ë‹¤ìš´ë¡œë“œ
        data = download_data_robust(tickers, start_date, end_date)
        
        # ë¶„ì„
        results = []
        for name, ticker in tickers.items():
            result = analyze_individual_asset(name, ticker, data, end_date)
            if result:
                results.append(result)
        
        logger.info(f"ë¶„ì„ ì™„ë£Œ: {len(results)}ê°œ ìì‚°")
        
        # ìì‚° ì„ íƒ ë° ë©”ì‹œì§€ ìƒì„±
        selected_assets = select_assets(results)
        message = create_portfolio_message(selected_assets, end_date)
        
        # ì¶œë ¥ ë° ì „ì†¡
        print("\n" + "=" * 50)
        print(message.replace('<b>', '').replace('</b>', ''))
        print("=" * 50)
        
        send_telegram(message)
        logger.info("âœ“ ë¶„ì„ ì™„ë£Œ")
        
    except Exception as e:
        error_msg = f"âŒ ë¶„ì„ ì˜¤ë¥˜: {str(e)}"
        logger.error(error_msg, exc_info=True)
        send_telegram(error_msg)
        raise

def validate_environment():
    """í™˜ê²½ ì„¤ì • ê²€ì¦"""
    try:
        test_url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/getMe"
        response = requests.get(test_url, timeout=5)
        if response.status_code == 200:
            logger.info("âœ“ í…”ë ˆê·¸ë¨ ì—°ê²° í™•ì¸")
            return True
        else:
            logger.error(f"âŒ í…”ë ˆê·¸ë¨ ì—°ê²° ì‹¤íŒ¨: {response.text}")
            return False
    except Exception as e:
        logger.warning(f"âš ï¸ í…”ë ˆê·¸ë¨ ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
        return True  # ë¶„ì„ì€ ê³„ì† ì§„í–‰

# ======================== [ì‹¤í–‰] ========================
if __name__ == "__main__":
    try:
        validate_environment()
        analyze_momentum()
        print("\nâœ… ëª¨ë“  ì‘ì—… ì™„ë£Œ!")
    except KeyboardInterrupt:
        logger.info("â¹ï¸ ì¤‘ë‹¨ë¨")
    except Exception as e:
        logger.error(f"ğŸ’¥ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}", exc_info=True)
